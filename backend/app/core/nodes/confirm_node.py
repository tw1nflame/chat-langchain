import inspect
import json
from typing import Dict, Any
from core.logging_config import app_logger
from core.nodes.shared_resources import llm
from core.nodes.sql_nodes import generate_query, execute_and_format
from core.nodes.viz_summary_nodes import generate_viz, generate_summary
from core.nodes.planner_node import planner
from core.nodes.nwc_node import generate_nwc_query, nwc_analyze, nwc_show_forecast
from core.nodes.nwc_train_node import call_nwc_train
from core.nodes.rag_node import update_rag_node, retrieve_rag_node
from langgraph.graph import END

# Map action names (as produced by planner) to node functions so we can extract docstrings
ACTION_TO_FUNC = {
    "GENERATE_SQL": generate_query,
    "EXECUTE_SQL": execute_and_format,
    "GENERATE_VIZ": generate_viz,
    "SUMMARIZE": generate_summary,
    "GENERATE_NWC_SQL": generate_nwc_query,
    "NWC_ANALYZE": nwc_analyze,
    "NWC_SHOW_FORECAST": nwc_show_forecast,
    "TRAIN_MODEL": call_nwc_train,
    "UPDATE_RAG": update_rag_node,
    "RETRIEVE_RAG": retrieve_rag_node,
}


def confirm_plan(state: Dict[str, Any]):
    """Prepare a human-readable summary of the plan and request user confirmation.

    Behavior:
    - If `state.get('temporary_session')` is True, skip confirmation and return immediately.
    - Otherwise, collect the planner-generated `state['plan']` and for each step extract a short
      docstring from the corresponding node function. Use the shared LLM to produce a concise
      summary describing what will be executed and asking for confirmation.

    Outputs:
    - If confirmation is required: return {
          "awaiting_confirmation": True,
          "confirmation_summary": <text>,
          "result": "PENDING_CONFIRMATION"
      }
    - If skipped (temporary session or no plan): return {"plan_confirmed": True}
    """
    try:
        app_logger.debug("confirm_plan_called", extra={
            "question": state.get("question", "")[:200],
            "plan_len": len(state.get("plan", []) or []),
            "plan_id": state.get("plan_id")
        })
    except Exception:
        app_logger.debug("confirm_plan_called_snapshot_failed")

    # Skip confirmation for temporary/stateless chats -> proceed immediately
    if state.get("temporary_session"):
        app_logger.info("confirm_plan: temporary session — skipping confirmation")
        return {"next_action": "CONFIRMED"}

    # If controller requested us to pause immediately after planner, stop execution now.
    # If a confirmation_summary already exists in state, reuse it and avoid re-calling LLM.
    if state.get("pause_after_planner") and not state.get("resuming"):
        app_logger.info("confirm_plan: pause_after_planner set — stopping execution to await user confirmation")
        if state.get("confirmation_summary"):
            # Summary already generated by controller, just set awaiting flag and wait
            app_logger.debug("confirm_plan_reuse_summary", extra={"plan_id": state.get("plan_id")})
            return {"awaiting_confirmation": True, "confirmation_summary": state.get("confirmation_summary"), "next_action": "WAIT"}
        # Otherwise, continue to generate summary below and then return WAIT

    # If we are resuming after user confirmed, skip confirmation and allow the graph to continue
    if state.get("resuming"):
        app_logger.info("confirm_plan: resuming after confirmation — skipping confirmation step")
        return {"next_action": "CONFIRMED"}

    plan = state.get("plan", []) or []
    if not plan:
        app_logger.info("confirm_plan: empty plan — nothing to confirm")
        return {"plan_confirmed": True}

    # Build human-readable list of steps with docstrings (no technical step names)
    steps_text = []
    for i, step in enumerate(plan):
        action = step.get("action") if isinstance(step, dict) else str(step)
        func = ACTION_TO_FUNC.get(action)
        ds = inspect.getdoc(func) if func else None
        short_ds = ds.splitlines()[0] if ds else "Описание недоступно."
        # Only include the human-friendly short description (do not print action/node names)
        steps_text.append(f"{i+1}. {short_ds}")

    steps_block = "\n".join(steps_text)

    # List of known NWC articles to help LLM recognize terms correctly
    known_articles = (
        "- Торговая ДЗ\n"
        "- Прочая ДЗ\n"
        "- Авансы выданные и расходы будущих периодов\n"
        "- Прочие налоги к возмещению ST\n"
        "- Прочие налоговые обязательства\n"
        "- Задолженность перед персоналом\n"
        "- Резерв по неиспользованным отпускам\n"
        "- Краткосрочный резерв по премиям\n"
        "- Прочее\n"
        "- Кредиторская задолженность по ОС\n"
        "- Авансы полученные\n"
        "- Авансы полученные(металлы)\n"
        "- Торговая КЗ\n"
        "- Авансовые платежи по налогу на прибыль\n"
        "- Обязательства по налогу на прибыль\n"
        "- ЧОК (нормализовано на расчеты с акционерами)"
    )

    # Include history in context if available (simple concatenation for now)
    history = state.get("chat_history", [])
    history_str = json.dumps(history[-5:], ensure_ascii=False) if history else "[]"

    # Compose prompt for LLM (request Russian summary)
    prompt = (
        f"Вы суммируете последовательность шагов, которые автоматизированный агент собирается выполнить.\n"
        f"История диалога: {history_str}\n"
        f"Текущий вопрос пользователя: {state.get('question', '')}\n\n"
        f"Запланированные действия (коротко):\n{steps_block}\n\n"
        f"СПРАВОЧНИК СТАТЕЙ ЧОК (используйте эти названия ТОЛЬКО если вопрос касается NWC/ЧОК):\n{known_articles}\n\n"
        "Важное условие: не используйте технические названия шагов или имена нод — опишите действия понятным русским языком, кратко и без терминологии.\n"
        "ЕСЛИ в вопросе пользователя указаны конкретные параметры (название статьи, дата, тип пайплайна/модели), ВЫ ОБЯЗАНЫ включить их в описание.\n"
        "ВАЖНО ПРО НАЛОГИ: Если пользователь спрашивает про 'Налоги' (Taxes) или 'Налог на прибыль', НЕ пытайтесь привязать это к статьям из СПРАВОЧНИКА СТАТЕЙ ЧОК (например, к 'Обязательства по налогу на прибыль'), если пользователь явно не указал полное название. 'Налоги' — это отдельная категория, не входящая в NWC.\n"
        "Критически важно: используйте БУДУЩЕЕ время (например, 'Будет запущен...', 'Агент выполнит...'). Не пишите 'Запущен' или 'Выполнено', так как пользователь только подтверждает эти действия.\n"
        "Кратко (1-2 предложения) опишите на русском языке, что планируется сделать (с указанием найденных параметров), и задайте вопрос для подтверждения, например: 'Продолжить выполнение этих шагов?'.\n"
        "Верните только текстовое резюме и вопрос на русском языке; не включайте JSON или блоки кода."
    )

    try:
        app_logger.info("confirm_plan: invoking LLM to generate confirmation summary")
        resp = llm.invoke(prompt)
        summary = resp.content.strip()
        app_logger.info(f"confirm_plan: summary generated (len={len(summary)})")

        return {
            "awaiting_confirmation": True,
            "confirmation_summary": summary,
            "result": "PENDING_CONFIRMATION"
        }
    except Exception as e:
        app_logger.error(f"confirm_plan: failed to generate summary: {e}")
        # In case of LLM failure, default to skipping confirmation (safe fallback)
        return {"plan_confirmed": True}
